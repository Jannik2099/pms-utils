import enum
from typing import Callable, ClassVar, Iterator

class Atom:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Atom, expr: str) -> None


                    Constructs a new Atom object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Atom) -> bool:
        """__eq__(self: pms_utils.atom.Atom, arg0: pms_utils.atom.Atom) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Atom) -> int"""
    def __ne__(self, arg0: Atom) -> bool:
        """__ne__(self: pms_utils.atom.Atom, arg0: pms_utils.atom.Atom) -> bool"""
    @property
    def blocker(self) -> Blocker | None: ...
    @property
    def category(self) -> Category: ...
    @property
    def name(self) -> Name: ...
    @property
    def slotExpr(self) -> SlotExpr | None: ...
    @property
    def usedeps(self) -> Usedeps: ...
    @property
    def version(self) -> Version | None: ...
    @property
    def verspec(self) -> VersionSpecifier | None: ...

class Blocker(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    strong: ClassVar[Blocker] = ...
    weak: ClassVar[Blocker] = ...

class Category:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Category, expr: str) -> None


                    Constructs a new Category object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Category) -> bool:
        """__eq__(self: pms_utils.atom.Category, arg0: pms_utils.atom.Category) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Category) -> int"""
    def __ne__(self, arg0: Category) -> bool:
        """__ne__(self: pms_utils.atom.Category, arg0: pms_utils.atom.Category) -> bool"""

class Name:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Name, expr: str) -> None


                    Constructs a new Name object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Name) -> bool:
        """__eq__(self: pms_utils.atom.Name, arg0: pms_utils.atom.Name) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Name) -> int"""
    def __ne__(self, arg0: Name) -> bool:
        """__ne__(self: pms_utils.atom.Name, arg0: pms_utils.atom.Name) -> bool"""

class Slot:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Slot, expr: str) -> None


                    Constructs a new Slot object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Slot) -> bool:
        """__eq__(self: pms_utils.atom.Slot, arg0: pms_utils.atom.Slot) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Slot) -> int"""
    def __ne__(self, arg0: Slot) -> bool:
        """__ne__(self: pms_utils.atom.Slot, arg0: pms_utils.atom.Slot) -> bool"""
    @property
    def slot(self) -> str: ...
    @property
    def subslot(self) -> str: ...

class SlotExpr:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.SlotExpr, expr: str) -> None


                    Constructs a new SlotExpr object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: SlotExpr) -> bool:
        """__eq__(self: pms_utils.atom.SlotExpr, arg0: pms_utils.atom.SlotExpr) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.SlotExpr) -> int"""
    def __ne__(self, arg0: SlotExpr) -> bool:
        """__ne__(self: pms_utils.atom.SlotExpr, arg0: pms_utils.atom.SlotExpr) -> bool"""
    @property
    def slot(self) -> Slot | None: ...
    @property
    def slotVariant(self) -> SlotVariant: ...

class SlotVariant(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    equal: ClassVar[SlotVariant] = ...
    none: ClassVar[SlotVariant] = ...
    star: ClassVar[SlotVariant] = ...

class Usedep:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Usedep, expr: str) -> None


                    Constructs a new Usedep object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Usedep) -> bool:
        """__eq__(self: pms_utils.atom.Usedep, arg0: pms_utils.atom.Usedep) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Usedep) -> int"""
    def __ne__(self, arg0: Usedep) -> bool:
        """__ne__(self: pms_utils.atom.Usedep, arg0: pms_utils.atom.Usedep) -> bool"""
    @property
    def conditional(self) -> UsedepCond | None: ...
    @property
    def negate(self) -> UsedepNegate | None: ...
    @property
    def sign(self) -> UsedepSign | None: ...
    @property
    def useflag(self) -> Useflag: ...

class UsedepCond(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    eqal: ClassVar[UsedepCond] = ...
    question: ClassVar[UsedepCond] = ...

class UsedepNegate(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    exclamation: ClassVar[UsedepNegate] = ...
    minus: ClassVar[UsedepNegate] = ...

class UsedepSign(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    minus: ClassVar[UsedepSign] = ...
    plus: ClassVar[UsedepSign] = ...

class Usedeps:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Usedeps, expr: str) -> None


                    Constructs a new Usedeps object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Usedeps) -> bool:
        """__eq__(self: pms_utils.atom.Usedeps, arg0: pms_utils.atom.Usedeps) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Usedeps) -> int"""
    def __iter__(self) -> Iterator[Usedep]:
        """__iter__(self: pms_utils.atom.Usedeps) -> Iterator[pms_utils.atom.Usedep]"""
    def __ne__(self, arg0: Usedeps) -> bool:
        """__ne__(self: pms_utils.atom.Usedeps, arg0: pms_utils.atom.Usedeps) -> bool"""

class Useflag:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Useflag, expr: str) -> None


                    Constructs a new Useflag object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Useflag) -> bool:
        """__eq__(self: pms_utils.atom.Useflag, arg0: pms_utils.atom.Useflag) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Useflag) -> int"""
    def __ne__(self, arg0: Useflag) -> bool:
        """__ne__(self: pms_utils.atom.Useflag, arg0: pms_utils.atom.Useflag) -> bool"""

class Version:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.Version, expr: str) -> None


                    Constructs a new Version object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: Version) -> bool:
        """__eq__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    def __ge__(self, arg0: Version) -> bool:
        """__ge__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    def __gt__(self, arg0: Version) -> bool:
        """__gt__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.Version) -> int"""
    def __le__(self, arg0: Version) -> bool:
        """__le__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    def __lt__(self, arg0: Version) -> bool:
        """__lt__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    def __ne__(self, arg0: Version) -> bool:
        """__ne__(self: pms_utils.atom.Version, arg0: pms_utils.atom.Version) -> bool"""
    @property
    def letter(self) -> str | None: ...
    @property
    def numbers(self) -> VersionNumber: ...
    @property
    def revision(self) -> VersionRevision | None: ...
    @property
    def suffixes(self) -> list[VersionSuffix]: ...

class VersionNumber:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __eq__(self, arg0: VersionNumber) -> bool:
        """__eq__(self: pms_utils.atom.VersionNumber, arg0: pms_utils.atom.VersionNumber) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.VersionNumber) -> int"""
    def __iter__(self) -> Iterator[str]:
        """__iter__(self: pms_utils.atom.VersionNumber) -> Iterator[str]"""
    def __ne__(self, arg0: VersionNumber) -> bool:
        """__ne__(self: pms_utils.atom.VersionNumber, arg0: pms_utils.atom.VersionNumber) -> bool"""

class VersionRevision:
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __eq__(self, arg0: VersionRevision) -> bool:
        """__eq__(self: pms_utils.atom.VersionRevision, arg0: pms_utils.atom.VersionRevision) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.VersionRevision) -> int"""
    def __ne__(self, arg0: VersionRevision) -> bool:
        """__ne__(self: pms_utils.atom.VersionRevision, arg0: pms_utils.atom.VersionRevision) -> bool"""

class VersionSpecifier(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    ea: ClassVar[VersionSpecifier] = ...
    eq: ClassVar[VersionSpecifier] = ...
    ge: ClassVar[VersionSpecifier] = ...
    gt: ClassVar[VersionSpecifier] = ...
    le: ClassVar[VersionSpecifier] = ...
    lt: ClassVar[VersionSpecifier] = ...
    td: ClassVar[VersionSpecifier] = ...

class VersionSuffix:
    def __init__(self, expr: str) -> None:
        """__init__(self: pms_utils.atom.VersionSuffix, expr: str) -> None


                    Constructs a new VersionSuffix object from the input expression.

                    :raises ValueError: The expression is invalid.

        """
    def __eq__(self, arg0: VersionSuffix) -> bool:
        """__eq__(self: pms_utils.atom.VersionSuffix, arg0: pms_utils.atom.VersionSuffix) -> bool"""
    def __hash__(self) -> int:
        """__hash__(self: pms_utils.atom.VersionSuffix) -> int"""
    def __ne__(self, arg0: VersionSuffix) -> bool:
        """__ne__(self: pms_utils.atom.VersionSuffix, arg0: pms_utils.atom.VersionSuffix) -> bool"""
    @property
    def number(self) -> str: ...
    @property
    def word(self) -> VersionSuffixWord: ...

class VersionSuffixWord(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    alpha: ClassVar[VersionSuffixWord] = ...
    beta: ClassVar[VersionSuffixWord] = ...
    p: ClassVar[VersionSuffixWord] = ...
    pre: ClassVar[VersionSuffixWord] = ...
    rc: ClassVar[VersionSuffixWord] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""
