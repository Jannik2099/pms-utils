import enum
from typing import Callable, ClassVar, Iterator, overload

class Atom:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Atom) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Atom) -> bool: ...
    @property
    def blocker(self) -> Blocker | None: ...
    @property
    def category(self) -> Category: ...
    @property
    def name(self) -> Name: ...
    @property
    def slotExpr(self) -> SlotExpr | None: ...
    @property
    def usedeps(self) -> Usedeps: ...
    @property
    def version(self) -> Version | None: ...
    @property
    def verspec(self) -> VersionSpecifier | None: ...

class Blocker(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    strong: ClassVar[Blocker] = ...
    weak: ClassVar[Blocker] = ...

class Category:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Category) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Category) -> bool: ...

class Name:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Name) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Name) -> bool: ...

class Slot:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Slot) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Slot) -> bool: ...
    @property
    def slot(self) -> str: ...
    @property
    def subslot(self) -> str: ...

class SlotExpr:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: SlotExpr) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SlotExpr) -> bool: ...
    @property
    def slot(self) -> Slot | None: ...
    @property
    def slotVariant(self) -> SlotVariant: ...

class SlotVariant(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    equal: ClassVar[SlotVariant] = ...
    none: ClassVar[SlotVariant] = ...
    star: ClassVar[SlotVariant] = ...

class Usedep:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Usedep) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Usedep) -> bool: ...
    @property
    def conditional(self) -> UsedepCond | None: ...
    @property
    def negate(self) -> UsedepNegate | None: ...
    @property
    def sign(self) -> UsedepSign | None: ...
    @property
    def useflag(self) -> Useflag: ...

class UsedepCond(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    eqal: ClassVar[UsedepCond] = ...
    question: ClassVar[UsedepCond] = ...

class UsedepNegate(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    exclamation: ClassVar[UsedepNegate] = ...
    minus: ClassVar[UsedepNegate] = ...

class UsedepSign(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    minus: ClassVar[UsedepSign] = ...
    plus: ClassVar[UsedepSign] = ...

class Usedeps:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Usedeps) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[Usedep]: ...
    def __ne__(self, arg0: Usedeps) -> bool: ...

class Useflag:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: Useflag) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Useflag) -> bool: ...

class Version:
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __eq__(self, arg0: Version) -> bool: ...
    @overload
    def __eq__(self, arg0: Version) -> bool: ...
    def __ge__(self, arg0: Version) -> bool: ...
    def __gt__(self, arg0: Version) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: Version) -> bool: ...
    def __lt__(self, arg0: Version) -> bool: ...
    @overload
    def __ne__(self, arg0: Version) -> bool: ...
    @overload
    def __ne__(self, arg0: Version) -> bool: ...
    @property
    def letter(self) -> str | None: ...
    @property
    def numbers(self) -> VersionNumber: ...
    @property
    def revision(self) -> VersionRevision | None: ...
    @property
    def suffixes(self) -> list[VersionSuffix]: ...

class VersionNumber:
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: VersionNumber) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __ne__(self, arg0: VersionNumber) -> bool: ...

class VersionRevision:
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: VersionRevision) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: VersionRevision) -> bool: ...

class VersionSpecifier(enum.Enum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[object]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    _value_repr_: ClassVar[None] = ...
    ea: ClassVar[VersionSpecifier] = ...
    eq: ClassVar[VersionSpecifier] = ...
    ge: ClassVar[VersionSpecifier] = ...
    gt: ClassVar[VersionSpecifier] = ...
    le: ClassVar[VersionSpecifier] = ...
    lt: ClassVar[VersionSpecifier] = ...
    td: ClassVar[VersionSpecifier] = ...

class VersionSuffix:
    def __init__(self, arg0: str) -> None: ...
    def __eq__(self, arg0: VersionSuffix) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: VersionSuffix) -> bool: ...
    @property
    def number(self) -> str: ...
    @property
    def word(self) -> VersionSuffixWord: ...

class VersionSuffixWord(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _missing_: ClassVar[method] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    alpha: ClassVar[VersionSuffixWord] = ...
    beta: ClassVar[VersionSuffixWord] = ...
    p: ClassVar[VersionSuffixWord] = ...
    pre: ClassVar[VersionSuffixWord] = ...
    rc: ClassVar[VersionSuffixWord] = ...
    def __format__(self, *args, **kwargs) -> str: ...
